package edu.rtu.dynamix.vdevs;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public abstract class Simulator {

    public enum Mode {
        PureVirtual,
        RealTime,
        VirtualDiscrete
    }
    
    Simulator coupledSimulator;
    
    protected Schedule schedule;
    
    /**
     * List of imminent models
     */
    protected List<AtomicVDEVSModel> imminent = new ArrayList<AtomicVDEVSModel>();
    
    protected List<ModelEvent> bogusInput = new ArrayList<ModelEvent>();
    
    /**
     * List of models activated by input
     */
    protected List<AtomicVDEVSModel> activated = new ArrayList<AtomicVDEVSModel>();
    
    protected SimulationEngine engine;

    public Simulator(SimulationEngine engine, DEVSModel model) {
        super();
        this.engine = engine;
        this.schedule = new Schedule(this);
        
        schedule(model, VDEVS.TIME_ZERO);
    }

    /**
     * Get the model's next event time
     * @return The absolute time of the next event
     */
    public long nextEventTime() {
        return schedule.minPriority();
    }

    /**
     * Execute the simulation cycle at time nextEventTime()
     */
    public void execNextEvent() {
        computeNextOutput();
        computeNextState(bogusInput, schedule.minPriority());
    }

    abstract SimulationData getSimulationData(AtomicVDEVSModel model);

    protected abstract void computeNextOutput();

    protected abstract void schedule(DEVSModel model, long t);

    protected abstract void execEvent(AtomicVDEVSModel model, boolean internal, long t);

    /**
     * Add an input to the input list of an an atomic model. If the model's active flag is false,
     * this method adds the model to the activated list and sets the active flag to true.
     * @param model
     * @param value
     */
    protected void injectEvent(AtomicVDEVSModel model, Event value) {
        SimulationData modelData = getSimulationData(model);
        if (!modelData.active) {
            modelData.active = true;
            activated.add(model);
        }

        modelData.inputsChanged = true;
        modelData.inputs.add(value);
    }

    /**
     * Route an event generated by the source model contained in the parent model
     * @param parent
     * @param src
     * @param x
     */
    protected void route(CoupledModel parent, DEVSModel src, Event x) {
        // Notify event listeners if this is an output event
        if (parent != src) {
            notifyListeners(src, x);
        }
        
        // No one to do the routing, so return
        if (parent == null) {
            return;
        }

        // Compute the set of receivers for this value
        List<ModelEvent> receivers = new ArrayList<ModelEvent>();
        parent.route(x, src, receivers);

        // Deliver the event to each of its targets		
        for (ModelEvent event : receivers) {
            // Check for self-influencing error condition
            if (src == event.model) {
                throw new RuntimeException("Model tried to influence self: " + src.getName());
            }

            // if the destination is an atomic model, add the event to the IO bag for that model
            // and add model to the list of activated models			
            if (event.model instanceof AtomicVDEVSModel) {
                injectEvent((AtomicVDEVSModel) event.model, event);
            } // if this is an external output from the parent model
            else if (event.model == parent) {
                route(parent.getParent(), parent, event);
            } // otherwise it is an input to a coupled model
            else {
                route((CoupledModel) event.model, event.model, event);
            }
        }
    }

    protected void computeNextSynchronousOutput(AtomicVDEVSModel model) {
        SimulationData simulationData = getSimulationData(model);

        simulationData.outputsSynchronous.clear();

        model.lambdaSynchronous(simulationData.outputsSynchronous);

        if (simulationData.outputsSynchronous.size() > 0) {
            for (Event pv : simulationData.outputsSynchronous) {
                routeSynchronous(model.getParent(), model, pv);
            }

            model.lambdaResultSynchronous(simulationData.outputsSynchronous);
        }
    }

    /**
     * Route an event generated by the source model contained in the parent model
     * @param parent
     * @param src
     * @param x
     */
    protected void routeSynchronous(CoupledModel parent, DEVSModel src, Event x) {
        // No one to do the routing, so return
        if (parent == null) {
            return;
        }

        // Compute the set of receivers for this value
        List<ModelEvent> receivers = new ArrayList<ModelEvent>();
        parent.route(x, src, receivers);

        // Deliver the event to each of its targets		
        for (ModelEvent event : receivers) {
            // Check for self-influencing error condition
            if (src == event.model) {
                throw new RuntimeException("Model tried to influence self");
            }

            // if the destination is an atomic model, add the event to the IO bag for that model
            // and add model to the list of activated models			
            if (event.model instanceof AtomicVDEVSModel) {
                AtomicVDEVSModel am = (AtomicVDEVSModel) event.model;
                boolean needOutputProcessing = am.deltaExtSynchronous(event);
                if (needOutputProcessing) {
                    computeNextSynchronousOutput(am);
                }
            } else if (event.model == parent) { // if this is an external output from the parent model
                routeSynchronous(parent.getParent(), parent, event);
            } else { // otherwise it is an input to a coupled model
                routeSynchronous((CoupledModel) event.model, event.model, event);
            }
        }
    }

    /**
     * Set the atomic model active flag to false, delete any thing in the output bag,
     * and return the input and output bags to the pools.  
     * Recursively clean up network model components.
     * @param model
     */
    protected void cleanUp(DEVSModel model) {
        if (model instanceof AtomicVDEVSModel) {
            SimulationData modelData = getSimulationData((AtomicVDEVSModel) model);
            modelData.active = false;

            modelData.inputs.clear();
            modelData.inputsChanged = false;

            modelData.outputs.clear();
            modelData.outputsChanged = false;
        } else {
            for (DEVSModel subModel : ((CoupledModel) model).getSubModels()) {
                cleanUp(subModel);
            }
        }
    }

    /**
     * Compute model transitions and build up the prev (pre-transition) and next (post-transition) component sets. 
     * These sets are built up from only the models that have the modelTransition function evaluated.
     * @param t
     */
    protected void processStructureChanges(double t) {
    }

    /**
     * Apply the specified inputs at time t and then compute the next model states.  
     * Requires that lastEventTime() <= t <= nextEventTime().
     * This, in effect, implements the state transition function of the resultant model.
     */
    private void computeNextState(List<ModelEvent> input, long t) {       
        if (t < schedule.minPriority()) {  // Clean up if there was a previous IO calculation
            for (AtomicVDEVSModel model : activated) {
                cleanUp(model);
            }
            clearActivatedModelList();
            
            for (AtomicVDEVSModel model : imminent) {
                cleanUp(model);
            }
            imminent.clear();
        } else if (t == schedule.minPriority() && imminent.isEmpty()) { // Otherwise, if the internal IO needs to be computed, do it
            computeNextOutput();
        }

        // Apply the injected inputs
        for (ModelEvent event : input) {
            if (event.model instanceof AtomicVDEVSModel) {
                injectEvent((AtomicVDEVSModel) event.model, event);
            } else {
                route((CoupledModel) event.model, event.model, event);
            }
        }

        // Compute the states of atomic models.  Store Network models that need to have
        // their model transition function evaluated in a
        // special container that will be used when the structure changes are
        // computed (see exec_event(.)).
        for (AtomicVDEVSModel model : imminent) {
            execEvent(model, true, t); // Internal and confluent transitions
        }
        executeExternalTransitions(t);

        processStructureChanges(t);

        // Cleanup and reschedule any models that changed state in this iteration
        // and survived the structure change phase.
        for (AtomicVDEVSModel model : imminent) { // Schedule the imminents		
            cleanUp(model);
            schedule(model, t);
            if (coupledSimulator != null) {
                coupledSimulator.schedule(model, t);
            }
        }
        scheduleActivatedModels(t);

        // Empty the bags
        imminent.clear();
        clearActivatedModelList();
    }

	protected final void clearActivatedModelList() {
		activated.clear();
	}

	protected final void executeExternalTransitions(long t) {
		for (AtomicVDEVSModel model : activated) {
            execEvent(model, false, t); // External transitions
        }
	}

	/**
	 * Schedule the activated models
	 * @param t
	 */
	protected final void scheduleActivatedModels(long t) {
		for (AtomicVDEVSModel model : activated) { 		
            cleanUp(model);
            if (model.getSimulationEngine() == engine) {
                schedule(model, t);
                if (coupledSimulator != null) {
                    coupledSimulator.schedule(model, t);
                }
            } else {
                model.getSimulationEngine().forceScheduleDiscr(model, model.getSimulationEngine().getTimeCurrent());
            }
        }
	}

    private void notifyListeners(DEVSModel model, Event value) {
        /*Event event = new Event(model, value);		
        for (iter = listeners.begin(); iter != listeners.end(); iter++)
        {
        (*iter)->outputEvent(event,sched.minPriority());
        }*/
    }

    public Schedule getSchedule() {
        return schedule;
    }

    protected void getAllChildren(CoupledModel model, Set<DEVSModel> modelSet) {
        Set<DEVSModel> tmp = new HashSet<DEVSModel>();
        // Get the component set
        model.getComponents(tmp);

        // Find the components of type network and update modelSet recursively
        for (DEVSModel iter : tmp) {
            if (iter instanceof CoupledModel) {
                getAllChildren((CoupledModel) iter, modelSet);
            }
        }

        // Add all of the local level elements to modelSet
        for (DEVSModel iter : tmp) {
            modelSet.add(iter);
        }
    }

    protected void unscheduleModel(DEVSModel model) {
        if (model instanceof AtomicVDEVSModel) {
            schedule.schedule((AtomicVDEVSModel) model, VDEVS.TIME_INFINITE);
            imminent.remove(model);
            activated.remove(model);
        } else {
            for (DEVSModel subModel : ((CoupledModel) model).getSubModels()) {
                unscheduleModel(subModel);
            }
        }
    }
}
